---
layout: post
title: 像高手一样学习Python
---

{{ page.title }}
================

> 行为学习理论：70%时间练习，20%与人时间沟通讨论，10%时间看书学知识

## 第一章 我与编程的过往
### 2016-11-27
> 我耗费了多年的时间“学习”编程，却始终没有学成。

&emsp;&emsp;从大学时期开始，就开始想着要学习计算机和编程，从最一开始吸引我的Flash动画和ActionScript，然后是做网页，HTML,DIV+CSS，兴趣主要集中在漂亮酷炫的东西上面，希望能做出一个特别漂亮，有艺术气息，还带点酷酷的代码在里面，然后兴趣又转向了Photoshop，AI，平面设计上来，有段时间特别想做平面设计师，觉得这样的职业特别自由，带有创意的工作，以为那就是我所向往的目标了。这期间看了很多书，零零散散的写着代码，但是没有成型的作品，但这不影响我继续把大把的时间投入到这里。  
&emsp;&emsp;时间一年一年的过去，后来毕业了，2009年，经融危机刚过， 工作不好找，加上我自己学的并不是计算机专业，也不是设计类专业，所以肯定是没有进入IT或者设计这一行的。我学的是汽车发动机设计，正式的名字叫热能与动力工程，所以毕业我就进入了汽车公司，当时是一家国企，倒闭的国企，毕业之前我们从来没有听过它的名字，然后一直就在汽车行业干了，干到9个月的时候，年轻气盛，也不觉得自己有几斤几两，反正就是不喜欢国企的风气，感觉自己至少应该做研发，往公司研发部投了简历，被婉拒。然后开始感觉待不下去了，又开始想起我一直念念不忘的计算机了，开始投简历找我当时依旧很有热情的Flash编程方面的工作，还真给我找到了一家不错的公司。美国华裔开的广告公司，做Flash互动广告。面试让我写个冒泡排序和小球弹跳动画，排序没写出来，小球弹跳勉强实现了。最后我竟然面上上了，后来那家公司的HR告诉我，是因为我简历写得有特点，我是对着他们招聘要求一条一条的回答问题式的描述自己的。反正就是说得自己每一条都符合，不符合的有热情，愿意学。当时由于这份突如其来的工作，让我感觉极度的自信膨胀，加上刚毕业那会觉得自己多么多么牛，肯定很有前途的感觉。还有刚毕业，觉得自己被压抑了那么多年，毕业了终于能过自己想过的潇洒生活了，天天出去high。喝酒聚会，遇上了几个酒肉朋友，天天出去喝酒，喝到白天上班头痛得不行。刚在公司报道，主要是学习，有个前辈带着学习，感觉自己很有劲头，不过渐渐的我发现自己水平好像不怎么样，要实现各什么效果，基本上靠一点点的试，当时完全没想过有算法这个东西。但是当时的我察觉不到自己的状态和水平，反正就是觉得自己好牛，过两年会去百度阿里这样的公司的。  
&emsp;&emsp;后来又一次公司开会，老板讲了不少，我也讲了不少，我在会上“畅所欲言”,觉得公司应该这样这样，然后那样那样。现在想来，应该是引起了老板的注意。后来老板会后单独想问我更深入的看法，然而，我早已江郎才尽，那个时候的我，屌丝气质未脱，加上对自己完全没有清醒的自我认知，最后几经周转，我被老板请离了公司。最后一次老板跟我谈话，我记得他说的是：“我现在说的话，你应该录下来，因为我现在无法劝动你，我说的你听不进去，你最大的问题是眼高手低”。现在回想起来，确实没错，当年的我，确实完全无法听进他的话，也对自己没有清醒的认知，不知道自己几斤几两，当时的我，脑子是热的，热得迷糊。  
再后来，我离开了公司，老板多发了我半个月工资，接下来两个月，不断的找工作，不断的被拒绝，我记得直到我找到工作的那一天，口袋里只剩下80块钱。那个阶段，我也体会到了一点，人是被逼出来的，那时候我为了找工作，已经到了再往上翻出对方公司留的联系电话，打过去问人家招不招人，然后把简历发过去，最后结果当然是人家礼貌性的让我把简历发过去，然后就没有然后了。
&emsp;&emsp;后来的工作，也一直在汽车行业了，拿着当时觉得不高不低的工资，算是安稳了一阵。干了两年，觉得工厂没前途，也有想过再找IT公司，发现自己能力不够，简历都没法写，也有想过回头去找当年的那家广告公司，因为我看他们也渐渐在成长，公司也壮大了不少，但始终也没有跨出那一步。今天到我写下这些回顾的时候，也是庆幸我没有那么做，因为，我觉得，直到我在写这篇回顾的时候，我现在的状态才算是带有一些成熟理性的味道了。因为，那时候我依旧没有真正学会任何一门编程语言。当然，现在我也没有学会，但是我隐约感觉大我该怎么去学了。在工厂干了两年，无足轻重的职位，然后就去了另外一家工程机械公司，那时候英语也不好，印着头皮去的，没想到通过了，当时的老板，现在的朋友，觉得我很不错，所以把我招了。在那里干了一年多的样子，然后来到了现在的公司，依旧是汽车行业，因为从工厂到现在这家公司是不能直接跳槽的，因为是同一家母公司，现在这家是研发中心，双方签订了协议，所以去那家工程机械公司就是为了中间过渡一下。  
&emsp;&emsp;2014年2月17加入现在的这家公司，到现在马上快三年了，最大的感受是，分工太细，工作内容很琐碎，一直觉得没前途，其实理性地讲，确实是一个没有前途的低端职位，不要跟着鸡汤逻辑想当然地认为每份工作都值得花十二分认真去做好，然后就会成为发光的金子，在这样的一个巨型跨国公司里面，如果被用在了螺丝钉的位置，你是不会变成关键零部件的。然后渐渐地开始觉得没意思了，因为每天的工作无非是做报告，开会，追着供应商要个计划时间。当我用VBA和Excel把报告和分析工作完全自动化了之后，剩下的工作就只是天天追着供应商要计划日期了，简单讲，就是追着别人让他们完成他们本该按时完成但是却没有完成的工作。我的时间就是日复一日地消耗在这样低级别的劳动上。然后又有一阵，我开始非常担心将来，如果这样继续下去，哪一天换工作了，我还能作什么。  
&emsp;&emsp;然后又想起了我的“挚爱”,编程。而这时候，我已经毕业将近6年，每一份工作内容都不一样，只有一点是一样的，那就是低端职位。2015年，我已经29岁，这样的年龄，让我再重新开始，学习编程，然后以零工作经验，非科班出身，去与那些计算机专业毕业的二十三四岁的年轻毕业生竞争同一个职位，日后还得熬夜加班，天天晚上十二点，期望工资还比他们高，而且我也不是在编程方面有惊人的天赋，而且是资质平平。但是我依然义无反顾的又开始学习计算机了，这一次，我有一些进步，开始补习那些欠缺的基础知识，买了很多书，比如：《深入理解计算机系统》，《现代操作系统》，《数据结构》，《离散数学》，还有网络知识，PHP，Python，HTML5，SQL之类的书和教程，猛学了一阵，还申请了域名和服务器，准备建网站。然后回头一想，想到了上面刚刚说的那一段，又发现好像不太现实。再一次半途而废。  
&emsp;&emsp;然后又停歇了一阵，申请换了个岗位，以为新岗位会大不同，然后依旧是个低端职位，和上一个职位相比几乎没有实质上的差别。开始几个月热乎了一阵，渐渐没有热情了，因为一眼看到头，这个岗位也没什么价值。我又开始想自己的出路了。这一次，我并没有把目标定在程序员上，因为我通过日常工作发现，程序员也行并不适合我，因为程序员这样的职位，在小公司，靠接单过日子，那就是乙方，作为程序员在一个项目中的角色是按照客户需求实现目标，会经历需求不断地被外行提出修改的意见的过程，还有工期，调试和维护，甚至还有用户培训，这些都跟纯粹的编程工作不一样，而且会消耗大量的时间。在大公司，每个程序员依旧是一个螺丝钉，每个人负责一小个模块，也算不上自由的创造。而且本质上还是按照别人的需求实现目标，并不是自己的创造意愿。而且我自身的目前状态也不可能让我从程序员开始下一次工作。这一次我把目标瞄上了数据分析，这是一个有点类似于程序员的工作，也需要写代码，也要与各种系统，数据库等等打交道，但是我理解这与程序员是有区别的。程序员需要准确实现客户提出的需求，产出的是一个程序，一套系统，准确来讲是产出了一个工具给客户使用，是工具的制造者。而数据分析，虽然也要写代码，也要实现客户的目标需求，但是数据分析工作包含了更多的创造性，如何挖掘出有价值的数据，并发现其中的规律并反馈给客户做决策指导，更像是提供咨询，而不仅仅是提供工具，我们是在企业以前让一大批程序员给他们制造的工具和系统中提取数据，分析其中隐藏的规律，然后给出结论。所以数据分析，重点在于分析，不在于搬砖。我也感觉到市面上对于数据分析师的定位和期望是不明确的，有的感觉就是在招程序员，有的是在招数据库管理员，有的是在招数据录入文员，还有高级一点的叫大数据系统架构，目标在于建立大数据平台，本质上还是在构建工具，而数据分析的本质是分析数据，不是写代码，管理数据库，建立平台或者数据录入，虽然这些和数据分析都有联系，但不是数据分析的核心内容。  &emsp;&emsp;在看了不少正在的数据分析岗位后，发现一个特点，就是数据分析是和行业联系比较紧密的，这是很合理的要求，数据只是一堆数字，背后的关键是运行的业务，也就是行业的运行模式，只有把业务和数据放在一起，才能得到有价值的信息。纯粹的数据分析有点空想和过于理论化，数据分析是应用型的，而不是像数学，物理意义的理论基础知识。  
&emsp;&emsp;以上就是我总结的这几年的工作经历回顾和对目前的目标，数据分析师的认识。跳出自己目前的状态，假设我两三年后再来看数据分析师这个职业，我想应该不会有太大偏差，现在的我毕竟成长了一些，不像当年学Flash的时候觉得自己喜欢的就是最有前途的，现在ActionScript已经进入“Goodbye World!”语言名单了。在我理解，未来数据的快速积累会带来数据量的暴增，传统商业企业信息化带来的数据积累，企业业务模式和互联网融合所带来的新数据，云计算，物联网，这些大数据产出的地方，会迅速积累出海量数据，简单的人力分析已经很快就不能满足数据分析需求。未来或许可以依靠云计算自身来处理云计算自身所带来的数据，或者更进一步，依靠人工智能来处理数据，但是本质还是数据分析，分析模型和分析方法都是数据分析师所定义的，然后传递给更加智能的机器来处理。所以我认为，将来数据分析会是一个有前途的职业。  

## 第二章 数据分析，我的明确方向
### 2016-11-27  
> 方向是有了，还需要更多的思考，方向的目标，我最终想做什么，成为什么？TBC


## 第三章 学习方法思考
### 2016-11-27  
> Learning by Doing,Learning by Thinking,Learning by Summarizing,Learning by Teaching,Not by Reading.

&emsp;&emsp;当我打出上面这句话的时候，我发现，以前我的学习方式，几乎完全是Leaning by Reading。多么令人遗憾的发现！  

&emsp;&emsp;以前的我，总以为认真看书就能掌握知识和技能。但是看了这么多年的编程的书，我并没有掌握编程。看书的两个巨大的坑是：  

1. 你顺着作者的思路往下看，以为自己懂了，完全没有自己总结，思考，尝试，一段时间后，你所看过的书会和你看过的电视剧一样被忘得一干二净，甚至比电视剧忘得快得多，因为电视剧还会设置各种各样的情节让你印象深刻，书本就没有这么撩人了。当合上书的时候，让你再复述一遍大概内容都很难，更别说理解和掌握了，更何况编程是需要大量刻意练习的技能  
2. 看书会让你自己以为你很努力，其实如果只看书，你只是在做无用功。  

&emsp;&emsp; 另外，知识和能力不是一回事，你知道了某个知识点，但是能不能把它转换为自己的一种能力，那就是另外一回事了，知识转换为能力需要“大量的刻意练习”。这是必做的功课，我以前都没有做，仅仅是Reading。所以学不会是必然的。另外一个我没学会的技能也存在同样的方法问题，那个技能是英语。  

## 第四章 开始Python学习 
### 2016-11-27
> 既然心也定了，方法也思考了，那接下来就按照计划和方法开始**==做==**吧！

### 2016-11-28
### Python环境搭建
&emsp;&emsp;Python是一门跨平台的动态语言，由Python解释器进行解释执行。在Linux,Unix, Mac OS, Windows下都可以运行，但是它与Windows之间的友好性差一点，主要是由于Windows的设计哲学和Linux的差异造成的，在Linux, Unix，Mac OS中都是自带Python的，用起来也方便。
刚开始的第一步，当然是搭建一个Python运行环境，在Windos和Linux中搭建的步骤大体一致，细节有差别，第一步是安装Python解释器，Windows下可以直接下载到二进制安装包，安装完成后就可以了。第二步就是针对自己的研究方向，安装特定的包，包是Python之所以强大的原因所在，因为开源社区的贡献，很多强大的包都被开发出来了，这样我们想要解决一类问题的时候，可以直接拿来用，而不是重复发明轮子。

&emsp;&emsp;那么，Python有这么多包，怎么管理呢？去哪下载呢？我们假设没有人去思考这个问题，那么各位大神开发出来的包，我们怎么才能拿到手装在自己的电脑上用起来？我们想象一下可能是这样的，某位大神开发了一个好用的包，然后因为分享不畅，很少有人知道，那么他的包就没有办法被别人使用了，经过了很长时间，渐渐有人知道了，然后用的人开始多了，他做了一个小小的官方网站，人们去可以去他的网站上下载，分享效率就提升了一个境界了，同时，全世界有好多大神，来自不同国家不同公司，他们也开始开发了不同的包，也有网站给我们下载了，或者他们可以用Github托管，这样会有更多的人知道这些包了。随着时间的推移，又有一批新成长起来的大神，本着“不要重新发明轮子”和无私的分享精神，在前辈的轮子的基础上开发出了新的包，提供新的功能，然后，问题就来了，当我们下载了一个大神的包，发现他还依赖以前某位大神的另一个包，或者好几位大神的包，那我们又要自己去找前辈大神的包来安装了，运气好的话，都找全了，运气不好可能找不到了。或者找到了，但是版本又不对。最后一番折腾，终于搞好了，但是花这么多时间满世界去找轮子，是不是很浪费生命呢。

&emsp;&emsp;上面想象的一连串场景，都是前辈们经历过的，这些问题都是伴随着Python的成长，一步一步的出现的，然后被前辈们一步一步的找到方法解决的，并在在不断的想出更好的办法，我们今天用的包管理方法有一个事实标准了，PyPI和pip工具。PyPI是Python Packages Index的缩写，它是一个在线的包仓库，有一群属于PyPA工作组的人负责维护它，给它制定标准，维护包的内容，开发更好用的包管理工具。这样的管理模式，听上去挺合理的，它是怎么形成的呢？是不是一开始就是这样的呢？其实，这都是前辈们一点点积累，一点点改进，经过了很多年，才成了现在这个样子，而且，现在的模式不是固定的，他正在改进，不断的成长，比如目前安装科学计算相关的包，因为包含很复杂的包含关系，所以直接通过pip还不能很好的安装成功，这一类包通常通过轮子来安装，就是whl格式的文件，它是被编译好的二进制包，安装它的方式是通过在轮子所在目录下执行pip install <轮子名字+.whl后缀>，就可以成功安装了，pip怎么又跟轮子扯到了一起？有的人会有这个疑惑，说明是知道的多一点了，因为pip工具和wheel轮子不是同时出现的，现在他们却又在一起了。如果带着这个疑惑去阅读Python手册中的"Packaging History"章节中的"Packaging History"部分，就可以找到答案。想知道答案自己去看。另外一种方法是：把后缀whl改成zip，然后将解压后的包文件，包dist-info两个文件夹放入Python/Lib/site-packages中即可。为什么可以这样，因为它其实就是一个压缩包，简单的设定了个whl的后缀。如果你用解压缩软件打开它，就能看到它内部的结构了。  
&emsp;&emsp;回到pip工具的正常用途，通过它可以直接从PyPI站点上安装最新版本的包，当然通过各种参数可以安装其它版本，也可以有其它功能选项，比如忽略本地缓存重新下载。除了PyPI直接安装之外，还可以自行下载安装包，然后解压打开里面的setup.py文件进行安装，疑问又来了，为什么一个py文件可以执行安装动作？正常不都是一个windows exe可执行程序吗？特别是Windows系统用久了的人会有这个错觉。其实如果亲自去看看，打开setup.py的源文件，你会看到里面导入了setuptools包，它也是早期的一个包管理工具，setup.py其实就是一个入口，通过它调用setuptools包的功能实现安装，那么安装又做了些什么？其实没有什么很高深的事情，就是配置各种参数，把包文件复制到正确的地方而已。不要被Windows安装程序的错觉误导了，安装一个包不需要修改注册表，不需要做很多系统设置，我们中Windows的毒有点深。从这里也可以清楚的理解到为什么pip工具，或者自己安装包之前必须安装setuptools包了，因为我们安装的时候要执行它呀亲。

&emsp;&emsp;下面就来记录下具体的信息资源了，概念讲过了，就得讲实物了。  
**Python官网**  
https://www.python.org  
在这里可以找到Python所有的好东西，基本上你想要的答案都在上面，就看你有没有读到正确的地方。比如我第一天开始Python给Python安装包的时候，各种不成功，甚至开始怀疑这么麻烦，这么不靠谱的包，Python真有这么好用吗？然后通过百度谷歌找了很多零散的答案，问题也没解决，反而更加困惑了，因为找答案的过程中你会发现很多人又提到了你不知道的知识点和方法，这些会让你更加迷惑，还有这个东西？这种困惑是仅仅通过搜索引擎搜索知识的弊端，因为搜到的都是零散的，碎片化的信息，大部分时候能直接解决问题，但是问题解决了，而并不知道背后的知识体系和完整的逻辑。就跟以前Windows系统问题一样，遇到一个就去搜，解决了，下次出现了新问题，再去搜，永远都在搜，不搜就不知道怎么办，这就是因为不懂得Windows系统的逻辑。但是现在的知识体系又及其庞大，你按顺序从头到尾先全部学一遍，然后想当然的认为自己都懂了，然后你会发现你什么都没懂，因为你只是看了一遍，因为你不是自己思考，而是跟着书中的思路。详见第三章。把这两种方法结合起来才是有效的方法，先动手开始做，然后会遇到问题，尝试解决，然后问题越积越多，困惑得不得了，然后再回头去系统的看完整的知识内容，这样就是带着问题去阅读了，阅读的过程基本上就是解惑的过程，思考和阅读是同时进行的，这样才能真正看懂。

**PyPI**
https://pypi.python.org/pypi  
The Python PackageIndex，这个就是前辈建立起来的在线Python包的仓库了。开源社区的力量让这里有，目前已经有9万多个包了，每天新增包的数量大约在50个左右。这个网站上不仅有包，还有关于如何下载，安装，制作发布，教程方面的内容，是一个完整的平台。我们可以在这里搜索自己想要的包，然后下载使用。刚刚想到一个问题，这个网站上没有看到所有包的完整清单的页面，那么我们怎么找到这个列表呢？谷歌一下， 发现了这个地址： https://pypi.python.org/pypi/?  
后面加个问好，就是所有列表了，因为有9万多，所以这个页面要刷新好久才能全部显示出来。另外，这个子站上面并没有完全的教程关于如何安装Python包的，也没有相关历史介绍，这部分内容在https://docs.python.org/ 子站下面，其中有一个章节是“Installing Python Modules”，这里全面的介绍了如何安装各种类型的包，相关工具的开发历史，有一个很清晰全面的历史。我已经在KFC坐着拿手机看完了这一章节，英文不太好，花了两个多小时，但是看完之后，第一天安装包遇到的各种疑惑基本全部得到了解决，对这一部分知识基本上有了清晰的认识。如果你不能理解这种感觉，就先把那一章看完，回来你就理解了。  
**pip**  
pip本质上也是Python的一个包，但是它是用来管理安装所有包的工具。已经成为Python的标准库一员，随Python一起安装。它通过命令行调用，用来安装和管理包。

**国内PyPI镜像**  
由于网络原因，国内直接连接PyPI下载的速度很慢，有时候还下载失败，所以世界各地都有镜像站点，国内最好的是豆瓣的，地址是：https://pypi.doubanio.com/simple/。用
pip install <packagename> -i url  

**科学计算包轮子**
这是一个实验室维护的站点，因为科学计算的包不太好安装，所以大部分用轮子安装。地址是：  
http://www.lfd.uci.edu/~gohlke/pythonlibs/  
另外，在很多次自己安装失败之后，发现提示错误写道：
```error: Microsoft Visual C++ 9.0 is required (Unable to find vcvarsall.bat). Get it from http://aka.ms/vcpython27```，这里发现了，打开网址后，自动跳转到微软的网站了https://www.microsoft.com/en-us/download/confirmation.aspx?id=44266，写着“Microsoft Visual C++ Compiler for Python 2.7”。下载了之后安装编译器，再安装，果然成功了，感觉好爽。既然有Python2.7的编译器，那么应该也有Python3的。不过尝试改网址后缀没成功，可能Python3不一样吧。  

**pyc文件**  
装了不少的包之后，发现几乎所有包里的每个.py文件附近（附近的意思是同一个目录）都有一个.pyc文件，查阅百度之后，pyc的文件主要是用来提高加载和运行速度，通常包的文件我们不会去改，如果我们调用它，Python会检查.py文件和.pyc文件的时间戳，如果一样，就会跳过编译步骤，直接加载.pyc文件。另外一个好处就是简单的隐藏下原代码。



**PyPA工作组**  
https://www.pypa.io/en/latest/
这个工作组负责许多和Python打包相关的项目，不断推进包管理平台和工具的革新。这里有一章节叫"Packaging History",清晰全面的罗列了从1998年开始包管理工具的成长历程。这个小组还维护着一个邮件列表distutils_SIG，有兴趣的人可以自己申请加入。SIG是Special Interest Group的意思，distutils原本是早期的打包工具，现在已经被替代了，但是它依旧作为底层模块被新的打包工具所依赖。

**Python Docs**  
https://docs.python.org/2/  
https://docs.python.org/3/  
分别是Python 2和Python 3的在线手册，其中Python 3的每个主要版本都有独立的手册，Python2只有一个版本，页面左上角有下载链接，有PDF,HTML,txt版本，Python 3还有EPUB版本，同时Python安装好了之后，电脑上也会直接安装一份手册，这可是宝典。手册中的链接是可以直接加载官网上面的页面的，只要网速好，体验都很好。

### 2016-12-01
**Python Packaging Tool历史**    
## 2013年以前
**1998:** distutils-sig讨论列表创建，讨论包管理工具distutils的开发。  
**2000：** distutils添加进Python1.6标准库。
**2001：** PEP241提出定义分发包的元数据，就是开发出来的包的数据的固定模板和格式。  
**2002：** Richard Jones开始开发PyPI,创建了PEP301来描述这个建议。  
**2003：** PyPI上线运行。
**2004：** Phillip Eby提出新工具setuptools,引进Egg格式，这个蛋后来成了Wheel的雏形，轮子的概念更有哲学性，Egg的一大创举是在Egg里面有一个文件申明它所依赖的包，并通过setuptools里面的setup方法自动进行安装。   
**2006：** Jim Fulton引进Buildout，我还不知道它是干什么的。  
**2007：** Ian Bicking提出virtualenv工具，用于创建相互独立的虚拟环境，概念我懂了，还不会用，暂时还没有这个需求。先等等。  
**2008：** Ian Bicking大神又提出了pip工具，牛逼啊，用来替换安装器easy_install，它是2004年的setuptools中的安装器。  
**2008：** distribute工具从setuptools中独立出来，为了建立一个更开放的项目。我也没用过，不知道效果咋样。  
**2011-02-28：** PyPA工作组成立，从Ian大神手中接过pip和virtualenv的维护工作，Carl Meyer, Brian Rosner 和 Jannis Leidel三位大神领导，PyPA成立的时候，大家还想了好几个名字，ianb-ng，这个也许是Ian Bicking new group，猜的。cabal，pack和Ministry of Installation。  
**2012-06-19：** 放弃把“Distutils2/Packaging” 加入Python3.3的计划，因为这个项目人手不够，进展不顺，然后pip就逆袭了。  

## 2013年
- PEP425和PEP427提出轮子Wheel概念，它是编译好的包，叫built-package。  
- Pycon 2013大会召开，会上Packaging Dev and User Summits--包开发者和用户峰会--，分享了未来打包方式的想法。  
- PyPA接管Python Packaging User Guide的维护工作。  
- pip v1.4添加新功能，支持Wheel轮子的安装， pip install 轮子名字.whl，注意要带上后缀。注意pip是2008年提出，轮子2013年提出，pip当年就支持了，高效。另外，这个时候还没有加入到Python标准库。  
- PEP438对pip提出修改意见，持续改进的节奏。
- setuptools边编译成轮子了，跨平台的。
- 重构pip install docs，指出setuptools和pip是自展层次结构的基础"Base"。
不太懂，应该说的是他们是包安装工具的基础。
- CDN站点启用，赞助的。
- easy_install支持md5之外的哈希，pip已经支持了。
- pip v1.3和easy_install v0.7默认支持SSL，提高传输可靠性。
- PyPi强制web用户使用SSL。
- PyPI支持认证的SSL客户端连接。
- Distribute合并回setuptools，setuptools开发合并到PyPA的BitBucket（和Git类似的源码托管商）账户。
- 核心包工具项目移到PyPA的BitBucket喝Git账户下。
- distlib发布到PyPI，pip开始依赖它。
## 2014年
- pip docs重构，以符合PyPA文档模板标准。
- PEP449移除基于DNS的镜像站点自动发现功能。
- pip v1.5升级，开始不依赖setuptools就可以安装Wheel了。
- virtualenv v1.11开始用轮子安装pip和setuptools的。
- Modern Installation and Packaging guides在官网挂出。
- PEP453在Python3.4中实现pip自举。
- PEP477提出把PEP453移植到Python2.7.9。
这一刻就是pip默认加入Python标准库了。
- setuptools v8.0和pip v6.0实施PEP440，这两个项目依赖于Packaging项目支持。
## 2015年
- PEP470不赞成使用非PyPI主机，这个建议被接受。
- setuptools v18.3支持禁用sys.path的操作，不知道是啥，没用过。
- pip v7支持```--install-option```和```--global-option```操作。
- pip v7开始缓存轮子文件，并且从缓存安装，取代从sdists安装。sdists意为Source Distribution，就是没有编译的包，与wheel相反。

### 2016-12-06

## 第五章 包安装总结--Windows+Ubuntu
> 从自己的实际学习和领悟过程开始，列出一个最接近我学习历程的问题列表

**1. 如何安装Python？**  
&emsp;Python是跨平台的，所以在三大OS平台上都可以用，但是安装方式有区别。对Python最友好的平台是Linux，基本上系统自带Python。如果没有，或者要升级的话，有两种方式：  
- apt-get install Python
- 下载源码包，下载可以自己去官网下载，也可以使用Linux命令wget，记得要以Linux的思维习惯来使用Linux。源码包就是.tgz后缀的文件，然后就是使用一系列的Linux命令(命令背后是一系列程序),进行解压，编译和安装，具体步骤我没尝试过，以后真需要了再操作一遍。  

> apt-get apt=Advanced Package Tool,是Linux下管理应用程序的主要方式，Python也是Linux下的一个应用程序。

Windows下安装也比较简单，因为都打包好了，去官网下载.msi格式的文件，分32位和64位，下载下来装上，同时为了能在命令行调用Python，通常需要把Python安装路径添加进入系统环境变量，环境变量是个啥？说白了就是设置一个固定名字的变量，比如PATH,然后给他添加一些值，比如Python路径，然后我们从命令行调用的时候，操作系统就在PATH的变量值路径中一个个搜，直到找到我们需要的Python程序为止。如果没找到，就会提示
```
XXX不是内部或外部命令，也不是可运行的程序或批处理文件。
```
说明系统找不到这个程序，为什么我只说了程序，因为本质上，上面提到的内部/外部命令，程序，批处理文件，本质上就是程序，还记得当年勇的ipconfig和ping命令吗？它们也是程序，在哪里呢？请打开```C:\Windows\System32```,然后通过首字母快速定位，你就会发现每一个命令就是一个程序，这么一看，这命令行和Linux一个味道嘛，Linux各种命令的背后也是对应着各种小程序，一个程序完成一项简单的工作。在这个目录下直接点击运行程序和在命令行运行是一个意思，但是因为大部分程序是没有界面的，所以点击运行无法传递参数，所以会一闪而过，但是你点击运行write.exe，就会打开写字板，点击notepad.exe，就会打开记事本，它们是有界面的，这里你会觉得熟悉了，因为你常常用它，反而不会觉得它不是一个命令，而是一个程序，实际上，你在cmd程序窗口输入notepad,就会运行记事本程序。这样，你就理解了，命令的背后是程序这个逻辑了，命令实际上就是程序的名字，后面的参数就是程序所需要的输入。  
&emsp;说到这里，微软在Win10上搞了个新东西，那就是cmd.exe的升级版,powershell，本质是一样的，但是比cmd更强大。

然后官方文档里面有一章专门讲安装的，有空去看看。

**2. 如何安装自己需要的包？**  

一般书上，在讲完安装Python之后，接着就是怎么安装工具包了。一般都是直接讲一个命令：pip install packagename。简单直接。然后装着装着就有问题了。

**3. 国内下载包的速度好慢啊，稍微大一点的包因为太慢而导致下载超时，然后直接失败了，本以为慢一点慢慢等就是了，结果一超时才发现不行啊**  
这个时候书上一般就没讲了，其实PyPi站点在全世界都是有镜像的，中国比较好用的是豆瓣，最新的地址是：
https://pypi.doubanio.com/simple/
用法是在pip工具里带上参数 
-i https://pypi.doubanio.com/simple/
在这里我们又成功的装上一批需要的包了，装完之后再研究下，别人为什么知道，我就不知道呢，肯定不是每次都是依靠搜索引擎找的零碎资料，然后再次搜索，搜到了PyPI Mirrors，这是PyPI的一个子站，里面有介绍和全球可用的Mirrors站点列表，进入之后会优先显示本国的。地址如下：
- https://pypi.python.org/mirrors  这个是PyPI子站。
- https://www.pypi-mirrors.org/  这是镜像状态。
状态分为三种，
- Fresh--新鲜的，指的是同步时间差小于1小时
- Aging--老化的，指的同步时间差在小时至1天之间
- Old--老旧的，指的是同步时间差大于1天  
从这个站点可以看到，豆瓣为Fresh，阿里云为Aging，但是响应速度上阿里云更快，豆瓣为3000毫秒左右，阿里云是500毫秒左右。其它都不怎么样。 
> https://pypi.doubanio.com/simple/  豆瓣  
http://mirrors.aliyun.com/pypi/simple/  阿里云  
注意阿里云是HTTP，不是HTTPS，豆瓣两个都可以，但是常用HTTPS.  同时都要带上simple目录。

那么这些镜像是如何与PyPI主站同步的呢？这些问题大神们在开发的时候都思考过了，有一个Mirroring协议来实现，具体咱也不用了解太多。想知道的去看：   
> PEP 381 -- Mirroring infrastructure for PyPI  
https://www.python.org/dev/peps/pep-0381/  

**最后总结下两种使用方式：**  
**Single Usgae:**   

```
pip install -i https://<mirror>/simple <package>
```
**Global settings:**   
**Linux/Unix/Mac默认：**  
Add ``~/.pip/pip.conf``  

**用户sunicy：**   
``/home/sunicy/.pip/pip.conf``  

**Windows默认：**  
``"用户目录"\pip\pip.ini``  
**用户sunicy：**  
``"用户目录"\sunicy\pip\pip.ini``  

代码：
```
[global]  
index-url = https://<mirror>/simple
```
请参考： 
- https://www.pypi-mirrors.org/  
- https://pip.pypa.io/en/stable/user_guide/#config-file  
第二个站点是pip在PyPA下面的子站。  
> 我现在用的windows,在C:\Users\Administrator\下面建立了pip文件夹，然后添加pip.ini配置文件,好用，速度飞起来。   

**4. 通过设置镜像了之后，又成功安装了不少包，中途又试了一些包，命名在网站上有目录，但就是pip安装不上，为什么呢？**  
这里我发现了一个可能的原因，这些包目录下只有轮子文件，没有pip可用的源码，比如``monstro``这个包，从网站目录进去，会发现只有轮子.whl文件。通过pip安装的时候会出错：  
``
Could not find a version that satisfies the requirement monstro (from versions: )
No matching distribution found for monstro
``  

pip install 直接安装monstro，会提示上面的错误说找不到，因为没有对应的源码文件，.whl是不会被匹配到的。  
### 2016-12-07

**假如真的一定要安装，而且还不想下载，怎么办呢？**   
我先尝试了一下直接把整个网址和目录都带上，然后带上.whl文件的名字，这样应该是可以的。  
``pip install http://mirrors.aliyun.com/pypi/simple/monstro/monstro-0.1.0-py3-none-any.whl``  
然后收到了下面这样的提示：  
``monstro-0.1.0-py3-none-any.whl is not a supported wheel on this platform.``  
这看上去和上面的错误不是一个意思，刚刚上面的错误是找不到文件，这里说的意思是：它不是此平台所支持的轮子。
想了一下，应该是和Python的版本有关，然后谷歌一下，果然，轮子名字里有py3，说明它支持的是Python3。观察了下文件名，也搜了下，规则如下：  
``{distribution}-{version}(-{build tag})?-{python tag}-{abi tag}-{platform tag}.whl``  
pip工具安装的时候会根据这4个tag做相应的检查判断，具体细节就不研究了，反正找到对应自己平台和系统的版本就行了。  
> 我们如何知道当前系统下的Python支持的包版本呢？pip工具首先会自动帮我完成，如果我们想事先查看的话，可以用这个命令：  
```>>import pip; print(pip.pep425tags.get_supported())```  
输入之后，我看到了我的电脑是win_amd64的。  

回到正题，上面的问题出在不支持平台，所以换一个包继续我们的研究。然后又找了pygame，他有轮子文件，也支持Python2,又试了一下，发现不行。看来还是老老实实的自己先下载轮子到本地，然后进入本地目录用pip安装吧。记得要带上.whl后缀。

**5. 如何下载安装轮子文件.whl？**  
这个比较简单，关键是去哪里找轮子，并且找到版本正确的轮子。一个比较稳定的轮子库在这里：  
http://www.lfd.uci.edu/~gohlke/pythonlibs/  
打开之后刚开始会发现只有一点点东西，其实是正在加载，因为链接数目太多，需要好几分钟才能完全显示整个页面。
大部分科学计算所需的轮子都来这里找就对了，最基础的那个经典组合``numpy-1.11+mkl``也在这里。
下载下来之后，放在合适的目录，最后不要带中文，然后在命令行进入对应目录，然后``pip install wheelname.whl``就可以了。其实本质上.whl就是个压缩包改了下后缀名，我们可以改成压缩文件后缀，然后解压到Python目录下的``~\Lib\site-packages``文件夹里面就可以了。但是为了保险，还是用pip靠谱，安全无痛。  

> 其实在PyPI站点里和各大镜像网站里也有这些轮子，比如访问阿里云或者豆瓣镜像，然后找到对应目录，进去之后挑选合适的轮子下载就可以了。  

### 2016-12-08

### Linux下Python环境搭建
**1. Windows下面的安装配置折腾得差不多了，Linux下面也要研究下，Ubuntu如何安装轮子？**   
新手学习Linux，我推荐弄个VMware，然后下个Ubuntu桌面版，带桌面的，命令行不熟悉的时候还可以用GUI方式操作，或者命令行操作了，然后用GUI打开对比感受一下，这样更直观，对于学习的理解也更好。  
下面一步步记录下从崭新菜鸟开始所需的知识，按照真实研究步骤开始。
1. 设置分辨率：右键-->Change desktop background-->Displays-->All settings--自己调整即可
2. 出现问题了，分辨率倒是可以调，但是Ubuntu出现了“Unknown Display”的错误，GUI操作乱糟糟的，无法准确定位，鼠标点的位置不是响应的位置。

**2. Ubuntu出现“nknown Display”，GUI操作乱糟糟，无法定位，如何解决？**  
开始百度和谷歌，花了将近一个小时找答案，没解决，但是基本上找到了原因，属于Ubuntu的一个Bug，在电脑上有双显卡的时候会出现这个问题，然后我看了下自己电脑，一个是Intel集成显卡，另一个是高级的Nvidia显卡。而且目前的电脑都是智能判断使用哪一块显卡的，比如玩大型游戏就会切换到Nvidia显卡。我的尝试解决步骤如下：
1. 按照网上的说法，用Linux命令修改分辨率，无效
2. 按照另一篇文章说的在Linux下面安装bumblebee-nvidia工具，无效
3. 然后尝试直接禁用集成显卡，在设备管理器禁用了集成显卡，无效，显示器也不亮了
4. 然后找到了正确的方法，在桌面右键-->NVIDIA控制面板-->管理3D设置-->首选图形处理器-->选择NVIDIA显卡
5. 之后再试，无效
6. 回头一想，既然是bug，然后bug是2015年的，现在已经马上2017年了，不如换一个新版本的Ubuntu，开始搞。
7. 装了新系统，还是解决不了，算了，不管了。
8. **12-09号早晨**发现，虚拟机放在笔记本主屏幕上基本没什么问题，放进外接的27寸显示器里面，就开始出现问题了，折中方案，暂时把虚拟机丢在笔记本显示器这边用。
9. **12-11上午**发现，只要把虚拟机放在被设定为**主显示器**的那一块屏幕上，就不会出现定位和GUI操作问题。比如我把外接显示器设为主显示器，然后把虚拟机放在这里，就没问题，反而放在笔记本屏幕上开始出现问题。

> Ubuntu虚拟机安装方法：  
- 去Ubuntu官网下载iso文件，作为镜像。
- 在VMware中建立虚拟机，使用下载的镜像即可。
- 装新的，如果不想要旧的了，在VMware里面，选中虚拟机-->菜单栏-->虚拟机-->管理--从磁盘删除。
- 创建好虚拟机后，VMware会用下载的镜像文件在自己指定的目录下生成虚拟机文件和环境，以后使用和更新，都在这里。大约有10G左右。  
> 注：虚拟机文件后缀是.vmx和.vmdk  
Ubuntu虚拟机建立好了之后，第一步系统会更新，这是必要步骤，等更新完了就好了。  

**3. 设置Ubuntu更新源：**  
为什么要设置更新源？因为国外服务器的话，天朝下载速度很慢，一般选择阿里云的就可以了，大品牌，值得信赖。    
> 搜索(就是左上角第一个图标)-->Software & Updates-->在里面选择服务器为阿里云就行了  

**4. 更新系统：**  
``sudo apt-get update``  
需要多等一会哦  
**5. 安装Python和Python3**  
``sudo apt-get install python``  
``sudo apt-get install python3``  
> 其实默认都是装好了的，命令输入后会提示最新版本已经安装。如果没有，就会安装。  

**6. 安装pip**  
pip就是Python的包了，属于Python的级别，而不是Ubuntu系统的级别，但是也可以用Ubuntn系统的apt-get 工具来安装，其实他俩是同一种东西，apt-get是Ubuntu系统管理应用程序的工具，pip是Python下面管理包（和应用程序一个意思）的工具。  
``sudo apt-get install python-pip``  
``sudo apt-get install python3-pip``  
看名字就知道差别了，Python 2和3的工具是分开的，因为他们各自维护自己的包。

**7.为Python的PyPI配置国内镜像**  
为什么？和Ubuntu源一样，国外服务器慢。
方法在上一章Windows那边已经讲了，直接贴过来。  

> **Linux/Unix/Mac默认：**  
Add ``~/.pip/pip.conf``  
**用户sunicy：**   
``/home/sunicy/.pip/pip.conf``  

代码：
```
[global]  
index-url = https://<mirror>/simple
```  
> http://mirrors.aliyun.com/pypi/simple/    
https://pypi.doubanio.com/simple/

顺便学习下Linux下建立文件的命令：  
- 进入目录： cd /目录/子目录/    
- cd /home/.pip/
- 新建文件夹：mkdir，必要的时候带sudo
- sudo vi pip.conf
- 然后就是vi的操作了，先进入插入模式，输入上面的信息，然后按ESC进入命令行模式，然后按``:``冒号，记住冒号是Shift+:那个键，我一开始直接按它，没反应过来,太傻了。输入wq，保存，如果忘记了sudo，会发现没有权限保存。  
- 折腾好久终于写好了，然后开始试着安装，又发现两个问题，第一个是下载速度没变，然后想到可能是用户权限不对，Ubuntu自动用的我的ken账户，应该不是系统最高权限的，所以可能需要在/home/ken/.pip/下面放这个pip.conf文件。
- 再次写好了，然后第二个问题来了，我写的是阿里云的镜像，它不是https的，Ubuntu说不安全，不给用，那就用豆瓣吧，它是https，同步更快，唯一缺点是比阿里云可能下载速度稍微慢一点。再次改好，再测，速度飞起来。 

> ~代表home目录；已``.``开头的文件夹和文件问隐藏的。
``~/.pip/``就代表home目录下的隐藏文件夹``.pip``。这个在安装了Python和pip之后是已经有了的。桌面版想看的隐藏文件的话，在目录下按Ctrl+H，就能暂时显示了。 

### 2016-12-09
**8. 升级pip**  
pip目前默认安装的是8.1.1版本，有新版本的9.0.1，所以要升级一下，不知道为什么不直接安装9.0.1，不管了，直接升级。命令如下：  
**On Linux or macOS:**  
``sudo pip install --upgrade pip``    
**On Windows:**  
``python -m pip install -U pip``  
> 一开始我傻不拉几的直接按照提示就写了``pip install --upgrade pip``，没带``sudo``,还好反应得快。然后加了sudo，还是不行，折腾好久，最后关了Terminal重新开，再带sudo又可以了，看来说是系统权限没反应过来。  

 升级的时候发现下面的新问题，  
```
Not uninstalling pip at  
/usr/lib/python2.7/dist-packages,   
outside environment/usr
```  
然后网上搜了很久，没找到直接的解决方案，倒是有说用``get-pip.py``来安装，不用``sudo apt-get install python-pip``安装和``sudo pip install --upgrade pip``升级。

去pip官网下载，其实就是在pypa网站下的子站，因为现在pip由pypa负责维护。  
https://pip.pypa.io/en/stable/installing/#installing-with-get-pip-py  
下好了开始安装，发现还是和刚才类似的问题，因为发现了pip 8.1.1已经安装了，现在既然有了get-pip.py，那么就可以放心的把pip先卸载了。运行  ``sudo apt-get remove pythn-pip``,然后重新运行``get-pip.py``。  
- ``sudo apt-get remove pythn-pip``
- ``cd /home/ken/Downloads/``
- ``python get-pip.py``
- ``pip --version``  

最后一步是检查版本的，终于搞定，所以有时候遇到问题不一定要死盯着那个问题，觉得直接解决那个错误才完美，换个角度，能解决就行，这是出于学习和解决问题效率的考虑。

终于前期准备全部完成，现在就是开始安装各种包了。  

**8. 安装各种需要的包**  
先看下已经装了啥，``pip list``，我的已经安装了  
- pip (9.0.1)
- setuptools (20.7.0)
- virtualenv (15.1.0)
- wheel (0.29.0)  
- numpy (1.11.2)
前4个是必须的工具，从numpy开始是我要安装的数据分析的各种包，现在开始。
安装可以一个个的装，也可以批量的装，批量的装就是在pip install后面加上多个包的名字，用英文空格分开即可。比如我第一下安装了``Matplotlib``和``pandas``这两个，就是用的 ``sudo pip install matplotlib pandas``，现在我有了豆瓣镜像，下载速度飞起来。然后我开始装``StatsModels``，下载的过程中pip自己帮我发现我忘了装``Scipy``,因为依赖``Scipy``，和另外一个``patsy``，一并都给我装好了。  
另外，有不少的Python包是可以用apt-get来安装的，因为好多Python包也放在了Linux的应用程序池里面，通常以python-开头，然后加上包名，比如python-matplotlib。

## 2016-12-09 晚上
**8. 包安装得差不多了，现在要让Windows和Ubuntu虚拟机直接进行复制粘贴和文件拖拽共享，怎么办？如何安装VMware Tools?**  
Ubuntu下包装得差不多了，开始考虑把在Windows环境下写的练习代码复制到Ubuntu下面，这样就不用重写了。  
先开始尝试复制粘贴，虚拟机提示"粘贴失败"，研究下来发现是没有正确安装VMware Tools.  
那么怎么安装呢？直接点VMware菜单"虚拟机"-->"安装VMware Tools",提示如下错误：  
``正在进行简易安装时，无法手动启动 VMware Tools 安装``  
百度一番，好多都不对，然后综合起来，找到了如下方法： 
1. 选中虚拟机，右键"设置"-->"选项"-->"客户机隔离"-->确认"启用拖拽"和"启用复制粘贴"是勾选状态
2. 选中虚拟机，右键"设置"-->"硬件"-->"CD/DVD (SATA)"-->"连接"-->选"使用ISO映像文件"-->"浏览"-->定位到VMware的安装目录下的一个名为linix.iso的映像文件，然后点确定.
3. 然后重新点菜单"虚拟机"-->"安装VMware Tools"，这时候Ubuntu系统左侧图标里面的一个DVD图标会弹出来，里面会有一个包"VMwareTools-9.6.2-1688356.tar.gz"
4. 将这个包复制到自己的Ubuntu系统里面方便操作的文件夹里，比如我复制到了/home/ken/下面
5. cd /home/ken，进入包所在目录，以下的命令为防止没有权限，可以先用su root命令切换权限。
6. tar xzf VMwareTools-9.6.2-1688356.tar.gz，会在相同目录下解压得到一个文件夹vmware-tools-distrib，这里面就是VMware Tool的安装文件了。
7. cd vmware-tools-distrib，进入目录
8. sudo ./vmware-install.pl。别写错了，一开始我写成了sodu，蠢哭了。
9. 然后会生成一大串log，让我们做选择的时候都有默认选项，一个都不用改，直接回车确认。有的步骤耗时比较久，会停顿，等着就行。
10. 最后成功了会看到下面这几行字,就代表你成功了。  
```
To enable advanced X features (e.g., guest resolution fit, drag and drop, and 
file and text copy/paste), you will need to do one (or more) of the following:
1. Manually start /usr/bin/vmware-user
2. Log out and log back into your desktop session; and,
3. Restart your X session.

Enjoy,

--the VMware team

```
11. 最后就是启用VMware Tools了，安装上面说的都可以，第一种我试过了，可以，就是去/usr/bin/下面运行vmware-user就可以了，跟Windows下运行程序一样。
12. **2016-12-11发现：**9号 装好了之后我是直接手动启动vmware-user程序之后就可以复制粘贴和拖拽的，12号发现不行了，然后我回到虚拟机的设置面板，在第二步设置``linux.iso``的地方，把“设备状态”下面的两个选项"已连接，启动时连接"都勾上了，应该只勾第二个就行了，然后重启，OK，又可以复制粘贴和拖拽文件了，当然你得确保Linux下的位置你是有权限的。

> 参考： http://www.linuxdiyf.com/linux/13056.html    
还搜到一些建立共享文件夹之类的方法，都没这个好。

## 2016-12-10下午 于南京图书馆
今天下午来图书馆看书的，主要是前两天折腾Ubuntu下面的安装，发现自己对于Linux的操作基本上是一抹黑，所以过来学点知识。以下是在图书馆用手机写的笔记，搬过来。

---
### 快速浏览《Linux Shell 脚本攻略》笔记  

&emsp;&emsp;看这本书的目的是获得Linux Shell命令的整体逻辑，记录如下：
- 大部分命令其实就是一个小程序，就是一个不带界面的软件，C语言写的软件就是这样
- root是系统最高权限，一般不用，$表示普通用户，#表示root，一般通过在$下面加sudo获得权限提升
- 命令由bash解析，叫Bourne Again Shell，在/bin/bash这里，命令可以一句句的在终端执行，也可以存为脚本文件.sh，然后传递给终端命令行，也可以加#! /bin/bash 转换为可执行文件
- 命令既然是软件，就会有各种用途的软件，比如爬虫，压缩，转换照片，文件对比，字数统计，文本处理
- 命令还负责和系统内核交互，对系统和系统上的资源进行管理，比如调用时间，查找文件，目录生成，系统备份，磁盘管理，进程管理
- 命令还负责网络管理，同名命令ipconfig,ping在windows下面都有，还可以读取数据库  
- Shell还包括编程语言特性，比如熟悉运算，变量，数组，函数，循环等等。

**总结：**  
&emsp;&emsp;命令构成了Linux所有的人机交互环境，它相当于windows系统的各种系统管理组件和各种软件的集合，windows把这些分门别类做成了不同的东西，有的叫管理工具，有的叫系统部件，有的叫软件，还有一大批第三方开发的大软件，小软件。而Linux里面都是以命令的形式统一展现，可以做一个类比，把windows配好，各种软件装好，然后把每个系统工具和每个软件都做一个快捷方式链接，统一存放在一个地方，然后用windows的命令行工具去那个地方调用，这就很像一个伪shell了，当然缺少了编程语言那一部分，函数，变量什么的，这个东西在win7之后也有了，以前也有，在cmd命令脚本里也有，类似VB，大致就是这样一个逻辑了。
以上就是我从本书获得的知识，达到目标.

&emsp;&emsp;总之要得到一个概念，shell是Linux下一些列工具的合体，一个工具只做一件事，并且把它做好。 
>Linux 哲学之：小即是美。

&emsp;&emsp;所以以后有什么需求，先问问谷歌有没有直接的命令工具，比如上面说的字数统计，就有一个叫wc的命令，他背后就是一个统计单词数的小软件，如果我们不知道，可能会自己用python写一个脚步文件，实现同样的功能，但是这样既耗时间，也不一定有别人的好用，还有就是通过几个命令（工具）组合使用，实现更多需求，就跟在windows下用多个软件完成自己的工作一个意思。  


## 2016-12-11 接着前天（9号）的内容
**9. 在Linux环境下运行Python代码文件**  
首先百度了一下，Linux下的个人文档一般放在哪里，答案是``home``目录。果断的输入
``sudo mkdir /home/dm``用于放我准备写的Python代码。然后顺便学了两个Shell命令。  
- pwd=Print Working Directory,基本功能是打印当前的工作目录，特殊用法还不会，以后遇到了再说。
- ~，准确来说这个不是命令，是一个目录缩写，就是当前用户登陆的主目录，比如我的Ubuntu系统，我的默认用户是ken,当启动终端之后，默认就是在``/home/ken``目录下的，``~``就是这个目录。  
如果在Shell中直接输入``~``，会提示：  
 ``bash: /home/ken: Is a directory``  
如果在Shell中直接输入``cd ~``，会直接回到``/home/ken``目录.  
```
ken@ubuntu:/home/dm$ cd ~
ken@ubuntu:~$ 
```
然后把文件复制粘贴过来，因为只有有权限的目录可以通过和Windows一样的复制粘贴操作，其它地方没有权限，所以现在home下面建个临时文件夹，然后再用Shell移动到其他地方。又学到一个新命令``mv``。  
**移动文件夹到另一个文件夹**  
``sudo mv sudo mv /home/ken/tmp1 /home/dm/``

**移动当前文件夹下的所有文件到上一级目录**  
``sudo cd * ../dm/tmp1``  
``sudo mv * ../``  

**删除临时文件夹tmp1**  
```
ken@ubuntu:/home/dm/tmp1$ cd ../
ken@ubuntu:/home/dm$ sudo rmdir tmp1
```

- ``cd``命令对单个文件目录名操作时，不用带``/``  
- 记录命令带上前缀比较好，这样逻辑更清晰
- 删除目录还可以用``rm -rf path``,
    - -r 就是向下递归，不管有多少级目录，一并删除
    - -f 就是直接强行删除，不作任何提示的意思
> 这里顺便学会了markdown多级列表，就是前面加上Tab,就是子列表了。而且不必是同类型的，意思是无序列表和有序列表可以混合使用。  

文件总是挪到Ubuntu系统的目标文职了，下面开始把之前在Windows下写的代码拿到Linux下面试试效果。 

**10. Linux下的Python代码文件如何运行?**  
我直接输入了python,进入Python环境，然后直接输入路径和代码文件的文件名，报错。

```
ken@ubuntu:/home/dm$ python
Python 2.7.12 (default, Nov 19 2016, 06:48:10) 
[GCC 5.4.0 20160609] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> /home/dm/hello.py
  File "<stdin>", line 1
    /home/dm/hello.py
    ^
```
正确的做法是把"path/filename.py"作为参数直接传递给python程序，就跟Shell下面的其它命令一个意思，因为命令本质上就是程序，Python被安装了，它就是Linux下的一个程序，本质上和make,mkdir等等没有区别，既然我们知道那些命令是命令名+参数的方式，那么Python也是这样的。只不过Python作为一个解释器，进入它自身环境之后，自身也可以解释合法的Python语句。  
另外，Shell也可以接收.sh的脚本文件进行运行，跟Python的.py文件是一个意思。  

```
ken@ubuntu:/home/dm$ python /home/dm/hello.py
hello World!
```
然后又学到了一点Linux知识，因为我在Windows下面写的Python代码文件习惯性的按照驼峰式命名了，就是有大小写，在Shell下面默认是区分大小写的，然后百度一下，发现这些是可以自己配置的，顺便还知道了命令获取帮助的方法：，输入命令按两次Tab。 
- vi删除整个文件内容
    - 进入vi,进入命令行模式，:1,$d
    - 1代表第一行，$代表最后一行，d代表删除
    - :4,$-2d就是代表保留前3行和最后两行，其余删除
    - 好像是不需要空格的
- vi中复制粘贴，进入插入模式，然后就可以复制粘贴了。不过好像只支持右键--paste
- 配置Bash，通过``sudo vi ~/.inputrc``文件配置
```
# do not show hidden files in the list
set match-hidden-files off
 
# auto complete ignoring case
set show-all-if-ambiguous on
set completion-ignore-case on
"\ep": history-search-backward
"\e[A": history-search-backward
"\e[B": history-search-forward
```  
> 注意：配置完了要重启终端才会生效  

配置完了发现python还是区分文件名大小写，再一搜才发现，这个忽略大小写是指的输入Linux命令自动补全的时候的大小写，比如：  
```
ken@ubuntu:~$ cd docu
```
再按一下Tab,会自动补全为:  
```
ken@ubuntu:~$ cd Documents/
```
虽然理解错了，也算学到了另一点。

> 看来大叔现在的这种以需求为出发点的学习方法是有效的，而且很符合知识掌握的过程：``感性认识--理性认识--实践``循环。
另外早上看到的一个学习理论也符合大叔现在的方法：行为学习理论：721法则。即：  
人要掌握一门技能，需要10%的时间学习知识和信息，70%的时间练习和实践，还有20%的时间与人沟通和讨论。  
看来，大叔之前光看书真的错了，好在大叔已经领悟到了，在写第一章节的时候有了类似的观点，只是没有这么精炼和数据化。会想起大叔前两年是如何赶鸭子上架从基本上不懂开始，写出第一个还比较复杂的VBA程序，然后一直不断的写工具，到现在，虽然不算精通，但是也可以自信的说自己会写VBA了，给我一个谷歌度娘，就能写出自己想要的东西。整个过程也看书，但是回想一下，看书所消耗的时间真的不算多，当时买了一本《Excel专业开发》（花的时间比较多，边看边练习），后面看了一本《学会VBA,菜鸟也高飞》（这一本一共只花了两个小时看完了，算是梳理知识点）。在后面就是不断的给自己写工具，给同事写工具，整体算来，练习时间是多余看书时间的。然后我学会VBA了。假如我只看书，顺着书的思路抄写一遍代码，可能我现在依然不会VBA。  

**11. Linux下Python代码测试效果如何？**  
不错，顺畅，然后稍微有些不一样，主要是系统环境造成，比如运行matplotlib的demo的时候提示没有tk库，直接apt-get install python-tk，搞定，若是在Windows下面缺东西，肯定又得一番折腾，看来我会渐渐爱上Linux。顺便装了个xlrd和xlwt包，Pandas需要的。  
> Tk库是一个GUI库，是 Tcl“图形工具箱”的扩展，它提供各种标准的 GUI 接口项，以利于迅速进行高级应用程序开发。  

至此，Python环境的搭建内容基本学完了，从11月26开始(笔记是从11月27开始的)写了将近一万五千字的笔记，加上练习，花费了16天，其中有学习动作的是11天，其余5天在干别的，当然不是整天学习，还要上班和处理生活中的事情。  

### 2016-12-13
## 第六章 进入主题-学习、使用Python  
> 我学Python的目的是要让它成为我工作和生活中的利器。不是看书来学理论的。

### 先来一个Python抢票工具练练手
因为目前我还没有能力自己写，虽然以前看了好厚一本书，但是大部分只是跟着书上的练习来抄写代码，虽然也是一种练习，但是是被动的，没有自己的主动思考，现在已经全部忘光了，就连基本语法都不记得了，只记得Python是用缩进来安排语法逻辑的。
> 所以以前的学习方法无效。现在要用行为学习理论的721法则了。

下面就是我弄出这个抢票工具的过程：
1. 先百度，找到了一篇教程，然后复制粘贴里面的代码
2. 因为格式不规范，缩进不对，调整了好久才弄正确，发现如果缩进不对，会产生一些很不好理解的错误
3. 因为用的是``splinter``，所以安装了它
4. 开始运行，调出各种低级错误之后，遇到了下面这个错误：
```
selenium.common.exceptions.WebDriverException: Message: 'chromedriver' executable needs to be in PATH. Please see https://sites.google.com/a/chromium.org/chromedriver/home
```
5. 其实我一开始没找到这里，因为教程的代码用了``traceback``，显示了一大串信息，我也是百度了好久最后才找到这里，说明调试经验不足啊。上面这个错误的意思是没有安装``chromedriver``，因为对浏览器的自动化操作需要一个Driver，然后去这里下载了，下载到一个.exe文件，因为看到说要安装，然后我就开始双击它安装了。
6. 然后我就遇到了下面这个错误：``Only local connections are allowed.``,然后我又以为我错了，然后又去谷歌，还有人告诉说用参数在命令行运行它。还是不行，最后终于搜到了splinter的官网，这里有全部的内容。看完之后终于明白了，所谓的安装其实就是能让splinter能找到driver所在的位置，Windows下配置环境变量就可以了。
7. 如何配置？思路是把``chromedriver``的路径放进Path，这里有个小技巧，你可以把
``chromedriver``放进一个独立的文件夹，然后在Path中添加这个路径，也可以把``chromedriver``直接放进先有的环境变量路径，比如``C:\Python27\``,``C:\Program Files (x86)\Google\Chrome\Application``,等等，也就是说你把``chromedriver``和Python或者Chrome放在一起也行。看你喜好。
8. 配置好了，我现在只配置了Chome的driver，还有firefox和remote的driver，用到再说。  

> **for Windows：**  
https://sites.google.com/a/chromium.org/chromedriver/getting-started   
http://splinter.readthedocs.io/en/latest/drivers/chrome.html#using-chrome-webdriver  
http://www.voidcn.com/blog/shuizhongmose/article/p-337714.html  
http://www.voidcn.com/blog/asmcvc/article/p-5746860.html   
**for Linux:**  
首先，Linux下面默认没有Google Chrome浏览器，先安装，又学习到了新知识：
- Linux下软件包的格式是.deb，适用于Debian和Ubuntu，还有.rpm，其它系统的，用不上不研究了。
- 安装方法，自己用Firefox浏览器下载，然后Ubuntu能识别.deb，安装程序会直接打开它安装，安装到最后好像剩一点没完成，但是我等了一会直接关掉，发现安装好了，默认装好了之后在图标那里没有发现，但是在搜索里面能找到，打开之后，我想把它固定到Lancher里面，简单，打开之后就有图标了，在图标上右键，点"Lock to the launcher"
- 另一种是命令行下载和安装，wget下载，dpkg安装，没试过，以后试试。
- 接下来安装chromedriver，这个用wget体验一下，【还没试过，用的时候就试试】

### 2016-12-21
间隔了8天没有写笔记了，其中，13,14，15号在开始写抢票代码，顺便学会了自动化测试库Splinter，感觉在实际应用中学习效果会更好，因为有目的性，需要达成特定的功能，会更加有探究精神，在这个过程中我几乎把Splinter的所有文档和API都研究了一遍,最后由于功能需求，把执行Javascript代码的API都用上了，如果是普通的列表式序列学习，执行Javascript这么“高级”的功能我是没有勇气去研究的，会不自觉的把它作为高级功能而不深入研究。  
然后自己动手写会留下点印象，以后写多了印象就深刻了，我写了三天这个代码，然后16,17,18,19这4天干别的事情去了，20号晚上再打开代码，发现略微有点遗忘的感觉，没有开始那几天熟悉了，说明==遗忘是一个绝对过程，所以要学习，还要练习，还要复习，而且不能间隔太久，否则间隔期的遗忘是会不断加速的。==  

### 2016-12-26
> 又过去了5天，21,22号在研究股票，23，24,25号在研究股票和抢火车票。票倒是用我写的脚本抢到了，股票数据没搞定。

为了看上去连贯一些，把21号写的3条记录细节挪到下面。  
**下面具体记录下细节:**  
- 之前已经记录过Driver的安装了，这里只说一点，这个是Splinter的需求，如果当时想到直接去看Splinter官方文档，效率会比直接Google高很多，因为搜索引擎的数据虽然直接，但不系统，逻辑性和完整性比较差。
- ``import``可以导入包里面的特定``class``，也可以用``*``导入所有``class``
- ``import time``和``from time import *``的区别？搜到知乎的答案了，import <package>是把工具箱拿给我，from <package> import \* 是把工具箱里所有东西都拿给我，前一种在调用函数的时候，**必须加上**"模块.函数",后一种而是**必须不加**"模块名"，如果加了反而会报错，思考了下，应该是命名空间的问题。知乎上的回答并没有强调这一点，它说的是直接调用函数就可以，没有说出不能加模块名的这一层意思。
- Splinter这样的包，真的是轮子，因为用的时候，只需要知道所用的函数的用途，然后引用函数就可以了，基本上是拿来就用，不需要深究它的内部实现，这几天研究股票顺手用了下R语言的quantmod包，三四句代码就能做个东西，确实方便。而且看了下它的官方文档，也都是每个函数的用途和调用方法，我们不需要去关注内部实现，但是我们需要理解它的用途，对于Splinter，它是用来操作的，我们需要知道每个操作的意义即可，相对简单，因为比如.click()，就是点击，理解了就行了。而对于quantmod这样的，它是量化计算的包，他所拥有的方法，除了获取数据，画图相关的之外，其它的有一些是专门用于计算的，我现在还不清楚有哪些，比如计算MACD线，我们应该自己去先弄清楚MACD线的计算方法，这样用的时候才不会脑子里朦朦胧胧的，同时，如果它提供了参数给我们设置，这个时候更加需要清晰的知道MACD的计算方式了，不然我们会对于每个参数都是一头雾水，这样“真傻瓜”式的应用是没有价值的，因为事后无法融会贯通。
- 从上一条可以得出以下结论：==其实各种包的使用并不难，仔细阅读下API很快就可以知道，不像我之前想象的那么困难重重，但是要真正的掌握它，需要的是包背后所包含的特定知识，比如Splinter背后需要浏览器，网页，JS，一点点HTTP知识，因为这些我都会了，所以我不觉得是这些知识支撑了我对于Splinter很好的理解；而对于quantmod这样的包，它所包含的是量化计算，金融数学方面的知识，这个是我没有的，所以后续使用的过程中会遇到这些知识和理解上的障碍，我甚至都无法准确知道需要哪些知识。==**工具只是用来实现想法和展现能力的，你有一个分析的念头，一段程序帮你计算出来验证你的预期是否正确，你会画画，Painter软件给你一个数字的画画的地方，而不是因为你会用Painter软件，然后你就会画画了，这是我之前接触到这个软甲的时候体会到的。**
> Painter 是一款数码素描和绘画的终极工具，是一款极其优秀的仿自然绘画软件，拥有全面和逼真的仿自然画笔。简单说就是模拟现实中的各种画笔和颜料，在电脑上画画。
- 今天再回头看看我写的抢票代码，其实就是Spinter的各种函数直接调用，再配上上面提到的浏览器，网页，JS，一点点HTTP知识，所以Python是一个很快速实现你的想法的工具，关键是你有这个想法所需要的知识基础，然才是Python和包的知识，这两部分都有了，才能很好的实现目的。
- 然后体会到一点，每个包都有特定的功能，比如Splinter，用完之后，我体会到它是用来做自动化测试的，基于原来的Selenium，本质上，用来写抢票插件不是最合适的，因为它的主要功能在于自动化，而抢票插件需要的不仅仅是自动化，还有==快==，因为用户浏览器操作不可能100毫秒之内输完账号密码然后点击登录按钮，所以，下一版本的抢票插件，应该用其它的包了，初步设想是Requests包。==为自己的需求选择最合适的轮子也是提升效率和质量的重要一环。==
- 现在看来，Python确实好用，以至于写完了插件，回头再看代码，好像没有什么特别难和特别需要记下来的，实现了就好了。
- 
